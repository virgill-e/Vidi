# Analyse Compl√®te : Web App de Suivi des D√©penses Personnelles

## 1. P√©rim√®tre Fonctionnel

### Gestion Multi-utilisateurs (Cloisonn√©e)
Le syst√®me doit permettre √† plusieurs utilisateurs (toi, tes colocataires ou amis) de s'inscrire et de se connecter. Chaque compte fonctionne en vase clos, appel√© architecture *multi-tenant* : aucune donn√©e, cat√©gorie ou transaction n'est partag√©e. 

### Saisie et Importation des Donn√©es
Puisque tu refuses la synchronisation automatique pour des raisons de souverainet√© et de contr√¥le, l'application doit proposer deux flux :

- **Saisie manuelle rapide** : Un formulaire optimis√© (raccourcis clavier, compl√©tion automatique des commer√ßants) pour encoder une d√©pense depuis un smartphone apr√®s un achat.
- **Importation de fichiers** : Un module d'import de fichiers CSV ou OFX export√©s depuis ta banque. Il faudra une interface de "mapping" pour associer les colonnes du CSV (Date, Montant, Libell√©) aux champs de ton application.

### Module OCR "No-AI" pour Tickets de Caisse
Pour scanner tes tickets de courses (pratique pour ton budget cuisine) sans utiliser d'API co√ªteuse, la solution repose sur la technologie de reconnaissance optique de caract√®res (OCR) traditionnelle. Des moteurs open source gratuits comme Tesseract permettent d'extraire le texte brut d'une image. Une fois le texte r√©cup√©r√©, l'application utilisera des expressions r√©guli√®res (Regex) pour identifier les √©l√©ments cl√©s :

- **Date** : recherche de formats type `JJ/MM/AAAA`.
- **Montant total** : recherche du montant le plus √©lev√© ou des mots-cl√©s comme "TOTAL" ou "TTC" suivis d'un format mon√©taire.
- **Commer√ßant** : recoupement du texte de l'en-t√™te avec ta base de donn√©es de commer√ßants connus.

### Cat√©gorisation et Moteur de R√®gles
Pour √©viter d'assigner manuellement chaque d√©pense issue d'un import CSV, il te faut un **moteur de r√®gles d'auto-cat√©gorisation**. Exemple : *Si le libell√© contient "Delhaize" ou "Colruyt", assigner automatiquement √† la cat√©gorie "Alimentation/Cuisine"*.

### Tableaux de Bord et Reporting
Des vues graphiques permettant d'analyser la r√©partition des d√©penses, l'√©volution du patrimoine net, et un comparatif budget d√©fini vs budget r√©alis√©.

---

## 2. Architecture et Stack Technique

Connaissant tes affinit√©s techniques, voici l'architecture recommand√©e :

### Frontend : Nuxt 3 (Vue.js)
- **Mode** : SPA (Single Page Application) ou SSR (Server-Side Rendering). Pour un tableau de bord derri√®re un login, une SPA classique est souvent suffisante et plus l√©g√®re √† h√©berger.
- **UI Framework** : Tailwind CSS coupl√© √† Nuxt UI ou Shadcn-vue pour cr√©er des composants d'interface modernes (tableaux de donn√©es, modales d'import) rapidement.
- **Gestion de l'√©tat** : Pinia pour g√©rer la session utilisateur et le cache des cat√©gories/transactions.
- **Graphiques** : Chart.js ou ApexCharts pour les visualisations de d√©penses par cat√©gorie.

### Backend : API REST en C# .NET (8 ou 9)
- **Architecture** : Clean Architecture (ou Vertical Slice Architecture) pour bien s√©parer la logique m√©tier (r√®gles de cat√©gorisation) de l'acc√®s aux donn√©es.
- **Int√©gration OCR** : Utilisation d'un "wrapper" C# open source pour Tesseract (comme le package NuGet `Tesseract`). Il faudra s'assurer que les biblioth√®ques C++ de Tesseract et les fichiers de langue (fran√ßais/anglais) sont install√©s sur le serveur h√¥te.
- **Authentification** : ASP.NET Core Identity avec √©mission de tokens JWT ou de cookies HTTP-Only pour s√©curiser les sessions.
- **Parsing de fichiers** : Utilisation de libraries comme `CsvHelper` pour parser les CSV et `OpenFINCH` (ou parseur custom) pour les fichiers OFX.

### Base de Donn√©es et Stockage
- **SGBD** : PostgreSQL. C'est le standard robuste qui g√®re parfaitement les relations financi√®res et permet d'utiliser des champs JSONB si tu souhaites stocker les donn√©es brutes des imports CSV.
- **Stockage de fichiers** : Un volume Docker local mont√© sur le backend, ou un conteneur MinIO (compatible S3) pour stocker les scans de tickets de caisse de mani√®re s√©curis√©e et isol√©e.

### Structure du Projet
```
expense-tracker/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Application/        # Use Cases & Services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Domain/             # Entities & Business Rules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Infrastructure/     # DB, OCR, FileStorage
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ API/                # Controllers & DTOs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Program.cs
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îî‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ app.vue
‚îÇ   ‚îú‚îÄ‚îÄ nuxt.config.ts
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îú‚îÄ‚îÄ composables/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îî‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ docker-compose.yml
‚îî‚îÄ‚îÄ README.md
```

---

## 3. Mod√®le de Donn√©es

Pour garantir une isolation parfaite, la cl√© √©trang√®re `UserId` doit √™tre pr√©sente sur toutes les tables principales.

| Table | Description et Champs cl√©s |
|:------|:---|
| **Users** | `Id`, `Email`, `PasswordHash`, `CreatedAt`, `UpdatedAt`. G√®re les acc√®s et authentification. |
| **Accounts** | `Id`, `UserId`, `Name`, `Type` (Courant, √âpargne, Esp√®ces), `Balance`, `Currency`. Repr√©sente les comptes bancaires/portefeuilles de l'utilisateur. |
| **Categories** | `Id`, `UserId`, `Name`, `Color`, `Icon`, `ParentCategoryId` (pour cr√©er une hi√©rarchie, ex: Cuisine > Ustensiles). Permet une organisation hi√©rarchique des d√©penses. |
| **Transactions** | `Id`, `AccountId`, `Amount`, `Date`, `Payee`, `CategoryId`, `Notes`, `ReceiptFilePath`, `Source` (Manual/Import/OCR). L'enregistrement principal de chaque op√©ration. |
| **Rules** | `Id`, `UserId`, `ConditionPattern` (Regex), `TargetCategoryId`, `Priority`. Les r√®gles pour l'auto-cat√©gorisation. |
| **ImportBatch** | `Id`, `UserId`, `UploadedAt`, `FileName`, `Status` (Pending/Processed/Failed). Permet de tracker les imports de fichiers. |
| **Payees** | `Id`, `UserId`, `Name`, `Category`. Base de commer√ßants connus pour am√©liorer l'autocompl√©tion et la reconnaissance OCR. |

---

## 4. Fonctionnalit√©s D√©taill√©es par Module

### Module 1 : Authentification et Gestion des Utilisateurs
**Endpoints API :**
- `POST /auth/register` : Inscription avec email unique et validation du mot de passe (min 8 caract√®res).
- `POST /auth/login` : Authentification et g√©n√©ration du JWT (dur√©e de vie 7 jours avec refresh token).
- `POST /auth/logout` : Invalidation c√¥t√© serveur si gestion des sessions.
- `POST /auth/refresh` : Renouvellement du JWT expir√©.
- `GET /users/profile` : R√©cup√©ration du profil de l'utilisateur authentifi√©.
- `PATCH /users/profile` : Modification des param√®tres utilisateur (langue, devise, fuseau horaire).

**S√©curit√© :**
- Hachage des mots de passe avec BCrypt ou Argon2.
- Tokens JWT sign√©s avec une cl√© asym√©trique (RS256).
- D√©lai de rate-limiting sur les endpoints de login (max 5 tentatives par minute).

### Module 2 : Gestion des Comptes
**Endpoints API :**
- `GET /accounts` : Listing de tous les comptes de l'utilisateur avec soldes.
- `POST /accounts` : Cr√©ation d'un nouveau compte (Courant, √âpargne, Esp√®ces, etc.).
- `PATCH /accounts/{id}` : Modification du nom ou du solde initial.
- `DELETE /accounts/{id}` : Suppression d'un compte (avec v√©rification : pas de transactions li√©es).
- `GET /accounts/{id}/balance-history` : Historique du solde (utile pour des graphiques).

**Frontend :**
- S√©lecteur de compte sur la page de saisie de d√©penses.
- Vue synth√©tique des soldes de tous les comptes.

### Module 3 : Saisie Manuelle de Transactions
**Endpoints API :**
- `POST /transactions` : Cr√©ation d'une transaction avec validation (montant > 0, date valide, cat√©gorie appartenant √† l'utilisateur).
- `GET /transactions?skip=0&take=50&category=1&account=1&startDate=2026-01-01&endDate=2026-02-26` : Listing avec filtres et pagination.
- `PATCH /transactions/{id}` : Modification d'une transaction existante.
- `DELETE /transactions/{id}` : Suppression.

**Frontend :**
- Formulaire rapide optimis√© pour mobile (champs : Date, Montant, Commer√ßant, Cat√©gorie, Notes).
- Autocompl√©tion du champ "Commer√ßant" bas√©e sur l'historique (table `Payees`).
- Raccourcis clavier : `Enter` pour valider, `Esc` pour r√©initialiser.
- Option pour d√©dupliquer les transactions (si deux transactions identiques sont d√©tect√©es).

### Module 4 : Importation de Fichiers (CSV/OFX)
**Endpoints API :**
- `POST /imports/upload` : Upload d'un fichier CSV ou OFX (validation MIME type).
- `GET /imports/{batchId}/preview` : Aper√ßu des transactions pars√©es (sans les sauvegarder).
- `POST /imports/{batchId}/process` : Validation et insertion dans la DB.
- `GET /imports/history` : Historique des imports (avec statuts).

**Logique C# :**
- Parser CSV en utilisant `CsvHelper` (NuGet).
- D√©tection automatique des colonnes si l'ordre est inconnu.
- Application des r√®gles de cat√©gorisation avant affichage du preview.
- Gestion des doublons : comparaison (Date, Montant, Payee) pour √©viter les imports en double.

**Frontend :**
- Zone de drop de fichier (drag & drop).
- S√©lection du format (CSV ou OFX).
- Mapper visuel des colonnes : l'utilisateur peut associer les colonnes de son export bancaire √† celles attendues (Date, Montant, Libell√©, etc.).
- Aper√ßu du r√©sultat avec possibilit√© de supprimer certaines lignes avant validation.

### Module 5 : Module OCR pour Tickets de Caisse
**Architecture :**
- Upload de l'image (formats accept√©s : JPEG, PNG, PDF monopages).
- Appel au service C# qui utilise Tesseract via le package NuGet `Tesseract`.
- Extraction du texte brut.
- Parsing avec regex pour identifier la date, le montant et le commer√ßant.
- Retour d'une d√©pense "pr√©-remplie" √† l'utilisateur.

**Endpoints API :**
- `POST /ocr/upload` : Upload d'un ticket.
- `GET /ocr/result/{uploadId}` : R√©cup√©ration du texte extrait et des donn√©es pr√©-remplies (suggestion de cat√©gorie bas√©e sur le commer√ßant).

**Frontend :**
- Modal de capture de ticket (avec webcam ou upload).
- Affichage du texte extrait (lisible et √©ditable).
- Formulaire pr√©-rempli avec les valeurs d√©tect√©es (date, montant).
- Option de validation directe ou de modification avant validation.

**Exemple de regex pour extraction :**
```csharp
// Montant : cherche les motifs "TOTAL : 25.50 ‚Ç¨" ou "TTC 123,45 EUR"
var montantPattern = @"(?:TOTAL|TTC)[\s:]*(\d+[,\.]\d{2})\s*(?:‚Ç¨|EUR)?";

// Date : cherche "JJ/MM/AAAA" ou "AAAA-MM-JJ"
var datePattern = @"(\d{2}/\d{2}/\d{4}|\d{4}-\d{2}-\d{2})";

// Commer√ßant : premi√®re ligne pertinente, souvent tout en majuscules
var merchantPattern = @"^([A-Z\s]+)(?:\n|$)";
```

### Module 6 : Moteur de R√®gles d'Auto-Cat√©gorisation
**Table `Rules` :**
- `ConditionPattern` : Cha√Æne regex (ex : `(Delhaize|Colruyt|Carrefour)`, `(Netflix|Spotify)`).
- `TargetCategoryId` : La cat√©gorie assign√©e si le pattern correspond.
- `Priority` : Num√©rique (0 = haute priorit√©). En cas de plusieurs r√®gles correspondantes, la premi√®re (priorit√© la plus haute) gagne.

**Logique de Traitement :**
- √Ä chaque import de transaction (manuelle, CSV ou OCR), le backend boucle sur les r√®gles de l'utilisateur.
- Il teste chaque regex contre le champ `Payee` (libell√© du commer√ßant).
- La premi√®re correspondance assigne la cat√©gorie automatiquement.
- L'utilisateur peut modifier apr√®s coup si la cat√©gorisation ne lui pla√Æt pas.

**Frontend :**
- Interface CRUD pour g√©rer les r√®gles.
- Testeur de r√®gles : l'utilisateur saisit un libell√© exemple et la regex est test√©e en temps r√©el.

### Module 7 : Cat√©gorisation Hi√©rarchique
**Structure :**
- Les cat√©gories peuvent √™tre imbriqu√©es (ex : Cuisine > Ustensiles, Cuisine > Courses).
- L'utilisateur cr√©e ses propres cat√©gories selon ses besoins.
- Les rapports peuvent agr√©g√©r par cat√©gorie parente.

**Endpoints API :**
- `GET /categories` : Listing de toutes les cat√©gories (avec hi√©rarchie).
- `POST /categories` : Cr√©ation (avec `ParentCategoryId` optionnel).
- `PATCH /categories/{id}` : Modification.
- `DELETE /categories/{id}` : Suppression (avec v√©rification : pas de transactions li√©es).

### Module 8 : Tableaux de Bord et Reportage
**Vues Disponibles :**

1. **Dashboard Principal**
   - R√©sum√© des soldes par compte.
   - D√©penses du mois en cours.
   - Graphique en camembert : r√©partition par cat√©gorie.
   - Graphique en courbe : tendance des d√©penses sur les 6 derniers mois.
   - Comparatif budget vs r√©alis√© (si des budgets sont d√©finis par cat√©gorie).

2. **Vue de D√©tail par Cat√©gorie**
   - Liste des transactions d'une cat√©gorie (filtrable par p√©riode).
   - D√©pense moyenne mensuelle.
   - Montant total d'un mois.
   - Export en CSV/PDF de la p√©riode s√©lectionn√©e.

3. **Rapport de Synth√®se**
   - Vue mensuelle/trimestrielle/annuelle.
   - Heatmap des d√©penses par jour de la semaine.
   - D√©pense par commer√ßant (top 10, par exemple).
   - Ratio d'√©pargne (solde initial - d√©penses total du mois).

4. **Analyse Budg√©taire (Optionnel)**
   - D√©finition de budgets par cat√©gorie.
   - Alerte si d√©passement.
   - Tendance vs budget sur les 12 derniers mois.

**Endpoints API (pour les rapports) :**
- `GET /analytics/overview?period=month&date=2026-02-01` : Vue d'ensemble.
- `GET /analytics/by-category?startDate=2026-01-01&endDate=2026-02-26` : R√©partition par cat√©gorie.
- `GET /analytics/trend?months=6` : Tendance sur N mois.
- `POST /exports/report?format=pdf&period=january-2026` : G√©n√©ration d'un rapport PDF.

---

## 5. S√©curit√© et Isolation Multi-Tenant

C'est le point critique d'une application multi-utilisateurs o√π chacun g√®re son propre argent :

### Principe Fondamental : Zero Trust
Chaque endpoint API doit v√©rifier que l'utilisateur acc√©dant dispose bien des droits sur la ressource demand√©e.

### Mise en ≈íuvre Technique

1. **Extraction de l'Utilisateur Authentifi√©**
   ```csharp
   var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
   if (userId == null) return Unauthorized();
   ```

2. **Global Query Filters dans Entity Framework**
   ```csharp
   modelBuilder.Entity<Transaction>()
       .HasQueryFilter(t => t.Account.UserId == userId);
   
   modelBuilder.Entity<Category>()
       .HasQueryFilter(c => c.UserId == userId);
   ```
   Cela garantit que chaque requ√™te d'une entit√© filtr√©e exclut automatiquement les donn√©es d'autres utilisateurs.

3. **Validation Syst√©matique**
   ```csharp
   // Avant de modifier une transaction
   var transaction = await dbContext.Transactions.FirstOrDefaultAsync(t => t.Id == id);
   if (transaction?.Account?.UserId != userId) 
       return Forbid("Access denied");
   ```

4. **Uploads S√©curis√©s**
   - Validation du MIME type r√©el (pas juste l'extension).
   - Taille maximale des fichiers (ex : 10 Mo pour les images, 50 Mo pour les CSV).
   - Noms de fichiers al√©atoires (GUID) pour √©viter les collisions ou injections.
   - Stockage hors de la webroot (impossible d'ex√©cuter des scripts).

5. **Chiffrement des Donn√©es Sensibles** (Optionnel mais recommand√©)
   - Notes de transactions : chiffrement AES-256 avec cl√© d√©riv√©e du mot de passe utilisateur.
   - Informations IBAN : masquage (affichage partiel ou chiffrement).

### Politiques CORS et CSRF
- **CORS** : Autorise les requ√™tes depuis le domaine du frontend uniquement.
- **CSRF** : Int√©grer des tokens CSRF pour les mutateurs (POST, PATCH, DELETE).

---

## 6. Infrastructure et H√©bergement (Dokploy)

Puisque tu as de l'exp√©rience avec Dokploy et l'auto-h√©bergement, ton VPS (Debian ou Ubuntu) sera parfaitement adapt√© :

### Fichier `docker-compose.yml`
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: expensetracker
      POSTGRES_USER: app_user
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      ConnectionStrings__DefaultConnection: Host=postgres;Database=expensetracker;Username=app_user;Password=${DB_PASSWORD}
      Jwt__SecretKey: ${JWT_SECRET}
      Jwt__Issuer: ${JWT_ISSUER}
      Jwt__Audience: ${JWT_AUDIENCE}
    depends_on:
      - postgres
    volumes:
      - ./storage:/app/storage  # Pour les tickets OCR
    restart: unless-stopped

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    environment:
      NUXT_PUBLIC_API_BASE: ${API_BASE_URL}
    restart: unless-stopped

volumes:
  postgres_data:
```

### Dockerfile Backend (avec Tesseract)
```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY ["ExpenseTracker.API/ExpenseTracker.API.csproj", "ExpenseTracker.API/"]
RUN dotnet restore "ExpenseTracker.API/ExpenseTracker.API.csproj"
COPY . .
RUN dotnet build "ExpenseTracker.API/ExpenseTracker.API.csproj" -c Release -o /app/build
RUN dotnet publish "ExpenseTracker.API/ExpenseTracker.API.csproj" -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS runtime
RUN apt-get update && apt-get install -y \
    tesseract-ocr \
    tesseract-ocr-fra \
    libtesseract-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY --from=build /app/publish .
EXPOSE 80
ENTRYPOINT ["dotnet", "ExpenseTracker.API.dll"]
```

### Dockerfile Frontend (Nuxt)
```dockerfile
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine
WORKDIR /app
COPY --from=build /app/.output .
EXPOSE 3018
CMD ["node", "server/index.mjs"]
```

### Configuration Dokploy
1. Cr√©er une nouvelle application pour le backend (r√©pertoire `/backend`).
2. Cr√©er une nouvelle application pour le frontend (r√©pertoire `/frontend`).
3. Cr√©er une base de donn√©es PostgreSQL manag√©e via Dokploy.
4. Configurer Traefik pour :
   - Rediriger `https://example.com/api/*` vers le backend sur le port 80.
   - Rediriger `https://example.com/` vers le frontend sur le port 3000.
5. G√©n√©rer les certificats SSL via Let's Encrypt automatiquement.

### Variables d'Environnement (`.env`)
```
DB_PASSWORD=xxxxxxxxxxxxx
JWT_SECRET=your-very-secret-key-here
JWT_ISSUER=https://yourdomain.com
JWT_AUDIENCE=expensetracker-app
API_BASE_URL=https://yourdomain.com/api
```

---

## 7. Roadmap de D√©veloppement Sugg√©r√©e

### Phase 1 : MVP - Socle et Saisie Manuelle (Semaines 1-3)
**Objectifs :**
- [ ] Mise en place de la base de donn√©es PostgreSQL et migrations Entity Framework.
- [ ] Impl√©mentation de l'authentification (Register / Login / JWT).
- [ ] Cr√©ation des entit√©s Domain (User, Account, Category, Transaction).
- [ ] Global Query Filters pour l'isolation multi-tenant.
- [ ] API REST minimale : CRUD Transactions, CRUD Accounts, CRUD Categories.
- [ ] Frontend Nuxt : Page de login, Dashboard avec listing des transactions, Formulaire de saisie rapide.
- [ ] Test int√©gration : v√©rifier qu'un utilisateur ne voit que ses propres donn√©es.

**Livrable :**
- Application fonctionnelle pour saisir manuellement des d√©penses et les consulter.

### Phase 2 : Importation et Automatisation (Semaines 4-6)
**Objectifs :**
- [ ] Impl√©mentation du parseur CSV (avec `CsvHelper`).
- [ ] Cr√©ation de la table `Rules` et logique d'auto-cat√©gorisation.
- [ ] Endpoint d'upload et preview de fichier.
- [ ] Logic pour √©viter les doublons.
- [ ] Frontend : Module d'import avec mapper de colonnes et aper√ßu avant validation.
- [ ] Tests des r√®gles : interface de test regex c√¥t√© frontend.

**Livrable :**
- Capacit√© √† importer des fichiers bancaires et auto-cat√©goriser les d√©penses via des r√®gles.

### Phase 3 : Module OCR (Semaines 7-9)
**Objectifs :**
- [ ] Installation et test de Tesseract dans l'environnement Docker.
- [ ] Impl√©mentation du service OCR en C# (extraction de texte + regex).
- [ ] Endpoint d'upload et de r√©sultat OCR.
- [ ] Integration avec les commandes pour d√©tecter le commer√ßant existant.
- [ ] Frontend : Modal de capture et formulaire pr√©-rempli.

**Livrable :**
- Scanner de tickets de caisse avec pr√©-remplissage intelligent des d√©penses.

### Phase 4 : Tableaux de Bord et Reporting (Semaines 10-12)
**Objectifs :**
- [ ] Endpoints analytics : r√©partition par cat√©gorie, tendances, etc.
- [ ] Frontend : Dashboard avec graphiques (Chart.js ou ApexCharts).
- [ ] Rapports PDF exportables.
- [ ] Heatmaps et analyses avanc√©es (optionnel).

**Livrable :**
- Vue compl√®te de la situation financi√®re avec graphiques et exports.

### Phase 5 : Optimisations et D√©ploiement (Semaines 13+)
**Objectifs :**
- [ ] Tests unitaires (xUnit pour le C#, Vitest pour Nuxt).
- [ ] Tests d'int√©gration (API avec base de donn√©es).
- [ ] Tests de s√©curit√© : v√©rifications multi-tenant.
- [ ] Monitoring : logs centralis√©s, alertes d'erreurs.
- [ ] Optimisation des performances : indexation DB, caching c√¥t√© API, SSG c√¥t√© frontend si possible.
- [ ] Documentation : README, architecture, guide de d√©ploiement.
- [ ] D√©ploiement sur Dokploy avec monitoring en continu.

**Livrable :**
- Application production-ready, s√©curis√©e, document√©e et auto-h√©berg√©e.

---

## 8. Consid√©rations Techniques Avanc√©es

### Performance et Scalabilit√©
- **Pagination** : Toujours limiter les r√©sultats (ex : 50 transactions par page) pour √©viter de charger la RAM.
- **Indexation DB** : Cr√©er des index sur les colonnes fr√©quemment filtr√©es (UserId, Date, CategoryId).
- **Caching** : Utiliser Redis (optionnel) pour cacher les cat√©gories, les r√®gles et les r√©sultats d'analytics fr√©quents.
- **Async/Await** : Toutes les op√©rations I/O (DB, fichiers) doivent √™tre asynchrones en C#.

### Monitoring et Logging
- **Serilog** : Framework de logging recommand√© pour C# (exporte vers fichiers, ElasticSearch, etc.).
- **Application Insights** (optionnel) : Suivi des performances et des erreurs.
- **Logs centralis√©s** : Stocker les logs sur le VPS avec rotation (logrotate).

### Tests Automatis√©s
- **Authentification** : V√©rifier que les tokens expirent et se renouvellent correctement.
- **Multi-tenant** : V√©rifier qu'un utilisateur ne peut pas acc√©der aux donn√©es d'un autre (tests de s√©curit√©).
- **OCR** : Tester le parseur regex sur divers formats de tickets belges.

### RGPD et Conformit√©
- **Droit √† l'oubli** : Ajouter une fonctionnalit√© pour supprimer compl√®tement les donn√©es d'un utilisateur.
- **Exportabilit√©** : Permettre l'export de toutes les donn√©es personnelles en JSON/CSV.
- **Politique de confidentialit√©** : Documenter ce qui est stock√© et comment.

### √âvolutivit√© Future
- **API GraphQL** : En cas de besoin de requ√™tes complexes, consid√©rer une migration vers GraphQL.
- **Synchronisation bancaire** : Si tu d√©cides ult√©rieurement d'int√©grer la synchro bancaire, utiliser des APIs comme Wise ou Plaid.
- **Mobile native** : Envisager une app Flutter/React Native qui consomme la m√™me API REST.
- **Notifications** : Ajouter des alertes email ou push si une d√©pense d√©passe le budget.

---

## 9. Estimations et Ressources

### Effort de D√©veloppement
- **MVP (Phase 1)** : ~80-100 heures (2.5-3 semaines √† 40h/semaine).
- **Phase 2 (Import + R√®gles)** : ~60-80 heures.
- **Phase 3 (OCR)** : ~40-60 heures (d√©pend de la complexit√© des tickets).
- **Phase 4 (Analytics)** : ~50-70 heures.
- **Total estim√©** : ~250-350 heures (3-4 mois √† temps plein, ou 6-9 mois √† temps partiel).

### Ressources Requises
- **Serveur** : Ton VPS (2 CPU, 4 GB RAM suffit amplement).
- **Domaine & SSL** : ~10-15 ‚Ç¨ /an (Let's Encrypt gratuit via Traefik).
- **Outils de d√©veloppement** : Visual Studio Community (gratuit) + Visual Studio Code (gratuit) + Rider (payant, ~150 ‚Ç¨/an, mais tu as peut-√™tre une licence pro).

### D√©pendances Cl√©s (NuGet & NPM)
**Backend C# :**
- `Microsoft.EntityFrameworkCore` (ORM).
- `Microsoft.AspNetCore.Authentication.JwtBearer` (Authentification).
- `CsvHelper` (Parsing CSV).
- `Tesseract` (OCR).
- `FluentValidation` (Validation de DTO).

**Frontend Nuxt :**
- `@nuxtjs/tailwindcss` (Styling).
- `pinia` (State management).
- `axios` (Client HTTP).
- `chart.js` ou `apexcharts` (Graphiques).
- `date-fns` (Manipulation de dates).

---

## 10. Checklist de Contr√¥le Qualit√© Avant Production

- [ ] Tous les endpoints retournent les codes HTTP corrects (200, 201, 400, 401, 403, 404, 500).
- [ ] Les erreurs incluent des messages utiles (pas juste "Error").
- [ ] Les donn√©es sensibles ne sont jamais logg√©es (ex : mots de passe, tokens).
- [ ] Les mots de passe sont hach√©s (BCrypt/Argon2), les tokens JWT sign√©s.
- [ ] Les tokens ont une dur√©e de vie limit√©e (7 jours) + refresh tokens.
- [ ] Tous les endpoints "lecture" test√©s : utilisateur A ne voit que ses donn√©es.
- [ ] Tous les endpoints "√©criture" test√©s : utilisateur A ne peut modifier que ses donn√©es.
- [ ] Les uploads de fichiers sont valid√©s (MIME type, taille, safe storage).
- [ ] Les regex OCR test√©es sur au moins 20 tickets vari√©s (Delhaize, Carrefour, petits commerces, etc.).
- [ ] Les imports CSV test√©s avec colonnes dans diff√©rents ordres.
- [ ] Les r√®gles de cat√©gorisation test√©es en cas de chevauchement (priorit√©s).
- [ ] Le site frontend fonctionne sur mobile (responsive design).
- [ ] Les erreurs de validation affichent des messages clairs √† l'utilisateur.
- [ ] La base de donn√©es est sauvegard√©e automatiquement (strat√©gie de backup).
- [ ] Les logs rotatifs configur√©s pour ne pas saturer le disque.
- [ ] Let's Encrypt SSL fonctionne et se renouvelle automatiquement.

---

## Conclusion

Cette application de suivi des d√©penses est **parfaitement r√©alisable en solo** avec ta stack de comp√©tences. Elle respecte tes contraintes (no IA, no API bancaire, multi-tenant cloisonn√©) et valorise tes talents de d√©veloppeur infrastructure + backend + frontend.

**Points forts du projet :**
‚úÖ Architecture Clean Architecture bien structur√©e.
‚úÖ Multi-tenant s√©curis√© par Global Query Filters.
‚úÖ OCR sans co√ªts r√©currents (Tesseract open source).
‚úÖ D√©ploiement enti√®rement self-hosted sur Dokploy.
‚úÖ Stack moderne et align√©e avec l'industrie.
‚úÖ Opportunit√© d'apprendre des bonnes pratiques (testing, security, monitoring).

**Prochaines √©tapes :**
1. Cr√©er le d√©p√¥t GitHub avec la structure du projet.
2. Mettre en place la base de donn√©es et les migrations.
3. Impl√©menter l'authentification en Phase 1.
4. It√©rer progressivement √† travers les phases.

Bon coding, et n'h√©site pas si tu veux des pr√©cisions sur une partie technique ! üöÄ

